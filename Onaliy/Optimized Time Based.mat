% Load and preprocess time-domain datasets
fileNames = {'Acc_TimeD_FDay.mat', 'Acc_TimeD_MDay.mat'}; % Time-domain data filenames
userData = struct();

% Loop through users and datasets to load data
for userID = 1:10
    for datasetIdx = 1:2
        fileName = sprintf('U%02d_%s', userID, fileNames{datasetIdx});
        if exist(fileName, 'file')
            loadedData = load(fileName);
            fieldName = sprintf('U%02d_%s', userID, fileNames{datasetIdx}(1:end-4));
            userData.(fieldName) = loadedData;
        else
            warning('File %s does not exist!', fileName);
        end
    end
end

% Define the fields and initialize storage for calculations
datasetFieldsTime = {'Acc_TimeD_FDay', 'Acc_TD_Feat_Vec'; 
                     'Acc_TimeD_MDay', 'Acc_TD_Feat_Vec'}; % Adjusted for time-domain features
meanTimeValues = zeros(10, 2);  
intraTimeVarianceValues = zeros(10, 2);
interTimeVarianceValues = zeros(2, 1);

% Feature calculation for mean, intra-variance, and inter-variance
for userID = 1:10
    for datasetIdx = 1:2
        datasetName = datasetFieldsTime{datasetIdx, 1};
        fieldName = sprintf('U%02d_%s', userID, datasetName);
        if isfield(userData, fieldName)
            featureField = datasetFieldsTime{datasetIdx, 2};
            data = userData.(fieldName).(featureField);

            % Calculate mean for time-domain data
            meanData = mean(data, 1);
            meanTimeValues(userID, datasetIdx) = mean(meanData);

            % Calculate intra-user variance for time-domain data
            intraVariance = var(data, 0, 1);
            intraTimeVarianceValues(userID, datasetIdx) = mean(intraVariance);

            % Calculate inter-user variance for time-domain data
            allData = [];
            for otherUserID = 1:10
                otherFieldName = sprintf('U%02d_%s', otherUserID, datasetName);
                if isfield(userData, otherFieldName)
                    otherData = userData.(otherFieldName).(featureField);
                    allData = [allData; otherData];
                end
            end
            interVariance = var(allData, 0, 1);
            interTimeVarianceValues(datasetIdx) = mean(interVariance);
        end
    end
end

% Plot the results for Time Domain Data
figure;

% Plot Mean Values for Time Domain Data
subplot(3, 1, 1);
bar(meanTimeValues);
title('Mean Values for Time Domain Data (Each User and Dataset)');
xlabel('User ID');
ylabel('Mean');
legend(datasetFieldsTime(:,1), 'Location', 'best');

% Plot Intra-Variance Values for Time Domain Data
subplot(3, 1, 2);
bar(intraTimeVarianceValues);
title('Intra Variance for Time Domain Data (Each User and Dataset)');
xlabel('User ID');
ylabel('Intra Variance');
legend(datasetFieldsTime(:,1), 'Location', 'best');

% Plot Inter-Variance Values for Time Domain Data
subplot(3, 1, 3);
bar(interTimeVarianceValues);
title('Inter Variance for Time Domain Data (Across All Users)');
xlabel('Dataset');
ylabel('Inter Variance');
xticks(1:2);
xticklabels(datasetFieldsTime(:,1));
legend('Inter Variance', 'Location', 'best');

% Build feature matrix and labels
featureMatrix = [];
labels = [];
for userID = 1:10
    for datasetIdx = 1:2
        meanData = meanTimeValues(userID, datasetIdx);
        intraVariance = intraTimeVarianceValues(userID, datasetIdx);
        interVariance = interTimeVarianceValues(datasetIdx);

        featureVector = [meanData, intraVariance, interVariance];
        featureMatrix = [featureMatrix; featureVector];
        labels = [labels; userID];
    end
end

% Standardize features
featureMatrix = zscore(featureMatrix);

% Feature selection using LASSO
[B, FitInfo] = lasso(featureMatrix, labels, 'CV', 10);
selectedFeatures = B(:, FitInfo.IndexMinMSE) ~= 0;
featureMatrixSelected = featureMatrix(:, selectedFeatures);

% Cross-validation setup
k = 5;
cv = cvpartition(length(labels), 'KFold', k);
accuracies = zeros(k, 1);

% Neural network configuration
hiddenLayerSizes = [5,3,5];
net = feedforwardnet(hiddenLayerSizes, 'trainlm');
net.layers{1}.transferFcn = 'poslin';
net.layers{2}.transferFcn = 'poslin';
net.layers{end}.transferFcn = 'softmax';

net.trainParam.epochs = 2000;
net.trainParam.min_grad = 1e-8;
net.trainParam.max_fail = 10;
net.trainParam.lr = 0.01; 
net.performParam.regularization = 0.001; 
net.divideParam.valRatio = 0.0;
net.trainParam.showWindow = false;

% Training and evaluation
for fold = 1:k
    trainInd = training(cv, fold);
    testInd = test(cv, fold);

    trainData = featureMatrixSelected(trainInd, :);
    trainLabels = full(ind2vec(labels(trainInd)'));
    testData = featureMatrixSelected(testInd, :);
    testLabels = labels(testInd);

    net = configure(net, trainData', trainLabels);
    [net, tr] = train(net, trainData', trainLabels);

    predictions = net(testData');
    [~, predictedClasses] = max(predictions, [], 1);

    accuracies(fold) = sum(predictedClasses' == testLabels) / length(testLabels);
end

meanAccuracy = mean(accuracies);
fprintf('Mean Accuracy across %d folds: %.2f%%\n', k, meanAccuracy * 100);

% Plot training performance
figure;
plotperform(tr);